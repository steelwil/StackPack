/*
 *  Copyright (C) 2006 - William Bell 
 *
 *  This file is part of the StackPack game
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <gtk/gtk.h>
#include <gdk/gdkkeysyms.h>
#include "callbacks.h"
#include "gameData.h"
#include "userData.h"
#include "StackPackEngine.h"
#include "view.h"
#include "scoresDlg.h"

extern struct GameDataStr gameData;
extern struct UserDataStr userData;
extern struct GameData gameEngineData[cMAXPLAYERS];
GdkEventExpose drawevent;
GtkWidget *drawwidget;
gint timertag;
	

/*----------------------------------------------------------------------------*/
void menuitem_new(GtkWidget *widget, gpointer data)
{
    printf ("new pressed %s\n", (char*)data);
	GameCreate(&gameEngineData[0],
							0,
						    0,
						    gameData.m_Base,  
							gameData.m_Height,
							gameData.m_StartingLevel,
							gameData.m_StartingRows,
							userData.m_PiecePreview,
							gameData.m_BlkType,
							gameData.m_LastLevel);
	viewRedraw(drawwidget, 2, &drawevent);
	timertag = g_timeout_add(gameEngineData[0].m_StepDuration,
				             timeout_callback,
				             NULL);
}

/*----------------------------------------------------------------------------*/
void menuitem_quit( gchar *string )
{
    printf ("quit\n");
	SaveUserData(&userData);
	//gtk_window_get_position(GTK_WINDOW (data), &userData.x, &userData.y);
	//printf("in quit x=%d, y=%d\n", userData.width, userData.height);
	SaveUserData(&userData);
	gtk_main_quit ();
}

/*----------------------------------------------------------------------------*/
gboolean configure_event(GtkWidget* widget, GdkEventConfigure *event, gpointer window)
{
	userData.width = GTK_WIDGET (window)->allocation.width;
	userData.height = GTK_WIDGET (window)->allocation.height;
	//gtk_window_get_position(GTK_WINDOW (data), &userData.x, &userData.y);
	printf("in configure_event x=%d, y=%d\n", userData.width, userData.height);
	//printf("in configure_event %s\n", (char*)data);
	viewResize(widget);
	return TRUE;
}

/*----------------------------------------------------------------------------*/
/* Redraw the screen from the backing pixmap */
gboolean expose_event( GtkWidget *widget, GdkEventExpose *event)
{
	viewRedraw(widget, 0, event);
	drawwidget = widget;
	return FALSE;
}

/*----------------------------------------------------------------------------*/
gboolean key_press_event(GtkWidget *widget, GdkEventKey *event)
{
/* 	printf("key pressed %d\n", event->keyval);*/
	int p, rc = 1;
	int area = 1;
	
	/* get highest level */
	int prevLevel = gameEngineData[0].m_Level;
	for (p=1; p<userData.m_NumberOfPlayers; p++)
	{
		if (prevLevel < gameEngineData[p].m_Level)
			prevLevel = gameEngineData[p].m_Level;
	}
	
	if (event->keyval == (userData.m_LeftKey1))
		GameLeft(&gameEngineData[0]);
	else if (event->keyval == (userData.m_RightKey1))
		GameRight(&gameEngineData[0]);
	else if (event->keyval == (userData.m_DownKey1))
		GameForceStepNow(&gameEngineData[0]);
	else if (event->keyval == (userData.m_RotateKey1))
		GameRotate(&gameEngineData[0]);
	else if (event->keyval == (userData.m_DropKey1))
		rc = GameDrop(&gameEngineData[0]);

	else if (event->keyval == (userData.m_LeftKey2))
		GameLeft(&gameEngineData[1]);
	else if (event->keyval == (userData.m_RightKey2))
		GameRight(&gameEngineData[1]);
	else if (event->keyval == (userData.m_DownKey2))
		GameForceStepNow(&gameEngineData[1]);
	else if (event->keyval == (userData.m_RotateKey2))
		GameRotate(&gameEngineData[1]);
	else if (event->keyval == (userData.m_DropKey2))
		rc = GameDrop(&gameEngineData[1]);

	else if (event->keyval == GDK_Pause || event->keyval == GDK_Escape)
	{
		if (!IsGamePaused(&gameEngineData[0]))
		{
			for (p=0; p<userData.m_NumberOfPlayers; p++)
			{
				GamePause(&gameEngineData[p]);
			}
			g_source_remove(timertag);
		}
		else
		{
			for (p=0; p<userData.m_NumberOfPlayers; p++)
			{
				GameStart(&gameEngineData[p]);
			}
			timertag = g_timeout_add(gameEngineData[0].m_StepDuration,
									 timeout_callback,
									 NULL);
		}
		if (event->keyval == GDK_Escape)
		{
			;// minimize the main window
			//gtk_window_iconify(GtkWindow *window);
		}
	}
	else if (event->keyval == 0) /* event from timer */
	{
		for (p=0; p<userData.m_NumberOfPlayers; p++)
		{
			rc = GameStep(&gameEngineData[p]);
			if (rc == 0) break;
		}
	}
	else
	{
		return FALSE;
	}
	for (p=0; p<userData.m_NumberOfPlayers; p++)
	{
		if (prevLevel < gameEngineData[p].m_Level)
		{
			viewResize(drawwidget);
			g_source_remove(timertag);
			timertag = g_timeout_add(gameEngineData[0].m_StepDuration,
									 timeout_callback,
									 NULL);
			area = 2;
			break;
		}
	}
	viewRedraw(drawwidget, area, &drawevent);
	for (p=0; p<userData.m_NumberOfPlayers; p++)
	{
		if (!IsGameInProgress(&gameEngineData[p]))
		{
			if (IsHighScore(&gameData, gameEngineData[p].m_Score))
			{
				AddHighScore(&gameData, "you", "your quote", 
							 gameEngineData[0].m_Score, 
							 gameEngineData[0].m_Lines, 
							 gameEngineData[0].m_Level);
				HighScoreDialogCreate(NULL);
			}
		}
	}
	
	return FALSE;
}

/*----------------------------------------------------------------------------*/
gint timeout_callback (gpointer data)
{
	printf("in timeout_callback\n");
	GdkEventKey eventkey;
	eventkey.keyval = 0;
	key_press_event(drawwidget, &eventkey);
	return (!gameEngineData[0].m_GameOver);
}

/*------------------------------------------------------------------------------
  Display the hightest scores
*/
void menuitem_scores (GtkWidget *window)
{
	HighScoreDialogCreate(window);
}

/*----------------------------------------------------------------------------*/
void destroy(GtkWidget *widget, gpointer data)
{
	//gtk_window_get_position(GTK_WINDOW (data), &userData.x, &userData.y);
	//printf("x=%d, y=%d\n", userData.x, userData.y);
	printf("in destroy %s\n", "hello");
	menuitem_quit(NULL);
}
